---
phase: 03-scoreboard
plan: 03
type: execute
wave: 2
depends_on: [03-02]
files_modified:
  - BarDown-iOS/BarDown/Models/GameModel.swift
  - BarDown-iOS/BarDown/Models/TeamModel.swift
  - BarDown-iOS/BarDown/Networking/APIClient.swift
  - BarDown-iOS/BarDown/Networking/GameEndpoint.swift
  - BarDown-iOS/project.yml
autonomous: true
requirements: [SCOR-01, SCOR-02, SCOR-03, TEAM-05]

must_haves:
  truths:
    - "GameModel and TeamModel are Decodable structs that exactly mirror the backend GameResponse and TeamBrief DTOs"
    - "GameModel.gameStatus computed property returns live/scheduled/final enum value for sorting"
    - "APIClient.shared can fetch games for a date and return [GameModel]"
    - "APIClient.shared can fetch available game dates and return [String]"
    - "API key is read from Info.plist build setting (not hardcoded)"
    - "DateFormatter uses America/New_York timezone for date strings"
    - "GameModelTests compile and pass (GREEN phase for model tests)"
  artifacts:
    - path: "BarDown-iOS/BarDown/Models/GameModel.swift"
      provides: "Decodable GameModel, GameStatus enum with Comparable"
      exports: ["GameModel", "GameStatus"]
      min_lines: 40
    - path: "BarDown-iOS/BarDown/Models/TeamModel.swift"
      provides: "Decodable TeamModel mirroring TeamBrief DTO"
      exports: ["TeamModel"]
      min_lines: 15
    - path: "BarDown-iOS/BarDown/Networking/APIClient.swift"
      provides: "URLSession wrapper with base URL, API key header, JSON decode"
      exports: ["APIClient"]
      min_lines: 50
    - path: "BarDown-iOS/BarDown/Networking/GameEndpoint.swift"
      provides: "Endpoint definitions for /games/date/:date and /games/dates"
      exports: ["GameEndpoint"]
  key_links:
    - from: "BarDown-iOS/BarDown/Networking/APIClient.swift"
      to: "BarDown-iOS/BarDown/Models/GameModel.swift"
      via: "JSONDecoder().decode([GameModel].self, from: data)"
      pattern: "decode.*GameModel"
    - from: "BarDown-iOS/BarDown/Networking/APIClient.swift"
      to: "Info.plist APIBaseURL / APIKey entries"
      via: "Bundle.main.object(forInfoDictionaryKey:)"
      pattern: "APIBaseURL|APIKey"
---

<objective>
Create the iOS data layer: local Decodable model structs that mirror the backend DTOs, and a networking service that calls the backend API with proper authentication and timezone handling.

Purpose: All subsequent UI plans depend on `GameModel` and `APIClient`. These are pure Swift types with no UIKit/SwiftUI dependencies — fast to build, easy to test. The GREEN phase for GameModelTests.

Output: Two model files, two networking files, project.yml update to add new source directories.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scoreboard/03-RESEARCH.md
@.planning/phases/03-scoreboard/03-02-SUMMARY.md

@Sources/App/DTOs/GameResponse.swift
@Sources/App/DTOs/TeamBrief.swift
@BarDown-iOS/project.yml
@BarDown-iOS/BarDownTests/GameModelTests.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GameModel, TeamModel, and GameStatus</name>
  <files>
    BarDown-iOS/BarDown/Models/GameModel.swift,
    BarDown-iOS/BarDown/Models/TeamModel.swift
  </files>
  <action>
Create the `BarDown-iOS/BarDown/Models/` directory and two model files.

**TeamModel.swift** — mirrors `TeamBrief` DTO exactly:
```swift
import Foundation

struct TeamModel: Decodable, Identifiable {
    let id: UUID
    let name: String
    let abbreviation: String
    let conference: String
    let logoAssetName: String?
    let record: String?
    let ranking: Int?
}
```

**GameModel.swift** — mirrors `GameResponse` DTO. Include `GameStatus` enum in the same file:
```swift
import Foundation

enum GameStatus: Int, Comparable {
    case live = 0
    case scheduled = 1
    case final_ = 2   // 'final' is a reserved Swift keyword — use final_ with raw string "final"

    static func < (lhs: GameStatus, rhs: GameStatus) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}

struct GameModel: Decodable, Identifiable {
    let id: UUID
    let homeTeam: TeamModel
    let awayTeam: TeamModel
    let homeScore: Int
    let awayScore: Int
    let status: String      // "scheduled", "live", "final"
    let period: String?
    let clock: String?
    let startTime: Date
    // quarterScores present in DTO but used by Phase 5 (Game Detail) — decode for completeness
    let quarterScores: [QuarterScoreModel]

    var gameStatus: GameStatus {
        switch status {
        case "live":    return .live
        case "final":   return .final_
        default:        return .scheduled
        }
    }

    var isLive: Bool    { status == "live" }
    var isFinal: Bool   { status == "final" }
    var isScheduled: Bool { status == "scheduled" }
}

struct QuarterScoreModel: Decodable {
    let quarter: Int
    let homeScore: Int
    let awayScore: Int
}
```

**Also add a static `placeholder` for .redacted skeleton loading:**
```swift
extension GameModel {
    static var placeholder: GameModel {
        GameModel(
            id: UUID(),
            homeTeam: .placeholder,
            awayTeam: .placeholder,
            homeScore: 0,
            awayScore: 0,
            status: "scheduled",
            period: nil,
            clock: nil,
            startTime: .now,
            quarterScores: []
        )
    }
}

extension TeamModel {
    static var placeholder: TeamModel {
        TeamModel(
            id: UUID(),
            name: "Team Name",
            abbreviation: "TM",
            conference: "Conference",
            logoAssetName: nil,
            record: "0-0",
            ranking: nil
        )
    }
}
```

**Date decoding:** The backend encodes `Date` as ISO8601 strings. The `APIClient` (Task 2) will configure `JSONDecoder.dateDecodingStrategy = .iso8601` — these models do not need custom CodingKeys unless field names differ from the Swift property names. The DTO field names match Swift camelCase already (`homeTeam`, `awayTeam`, etc.) so no CodingKeys needed.
  </action>
  <verify>
    <automated>xcodebuild build -project BarDown-iOS/BarDown.xcodeproj -scheme BarDown -destination 'platform=iOS Simulator,name=iPhone 17 Pro' 2>&1 | tail -5</automated>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    `xcodebuild build` exits 0. `GameModel`, `TeamModel`, `GameStatus`, `QuarterScoreModel` types exist with correct fields. Static placeholders available for skeleton loading.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create APIClient and GameEndpoint networking layer</name>
  <files>
    BarDown-iOS/BarDown/Networking/APIClient.swift,
    BarDown-iOS/BarDown/Networking/GameEndpoint.swift,
    BarDown-iOS/project.yml
  </files>
  <action>
Create the `BarDown-iOS/BarDown/Networking/` directory and two networking files. Update project.yml.

**GameEndpoint.swift** — endpoint URL construction:
```swift
import Foundation

enum GameEndpoint {
    case gamesForDate(Date)
    case availableDates(from: Date, to: Date)

    private static let easternFormatter: DateFormatter = {
        let f = DateFormatter()
        f.dateFormat = "yyyy-MM-dd"
        f.timeZone = TimeZone(identifier: "America/New_York")!
        return f
    }()

    func url(baseURL: URL) -> URL {
        switch self {
        case .gamesForDate(let date):
            let dateString = Self.easternFormatter.string(from: date)
            return baseURL.appendingPathComponent("/api/v1/games/date/\(dateString)")

        case .availableDates(let from, let to):
            let fromString = Self.easternFormatter.string(from: from)
            let toString = Self.easternFormatter.string(from: to)
            var components = URLComponents(url: baseURL.appendingPathComponent("/api/v1/games/dates"), resolvingAgainstBaseURL: false)!
            components.queryItems = [
                URLQueryItem(name: "from", value: fromString),
                URLQueryItem(name: "to", value: toString)
            ]
            return components.url!
        }
    }
}
```

**APIClient.swift** — URLSession wrapper with API key header injection:
```swift
import Foundation

@MainActor
final class APIClient {
    static let shared = APIClient()

    private let session: URLSession
    private let baseURL: URL
    private let apiKey: String

    private let decoder: JSONDecoder = {
        let d = JSONDecoder()
        d.dateDecodingStrategy = .iso8601
        return d
    }()

    private init() {
        self.session = .shared
        let baseURLString = Bundle.main.object(forInfoDictionaryKey: "APIBaseURL") as? String ?? ""
        self.baseURL = URL(string: baseURLString) ?? URL(string: "http://localhost:8080")!
        self.apiKey = Bundle.main.object(forInfoDictionaryKey: "APIKey") as? String ?? ""
    }

    func fetchGames(for date: Date) async throws -> [GameModel] {
        let url = GameEndpoint.gamesForDate(date).url(baseURL: baseURL)
        return try await fetch([GameModel].self, from: url)
    }

    func fetchAvailableDates(from: Date, to: Date) async throws -> [String] {
        let url = GameEndpoint.availableDates(from: from, to: to).url(baseURL: baseURL)
        return try await fetch([String].self, from: url)
    }

    private func fetch<T: Decodable>(_ type: T.Type, from url: URL) async throws -> T {
        var request = URLRequest(url: url)
        if !apiKey.isEmpty {
            request.setValue(apiKey, forHTTPHeaderField: "X-API-Key")
        }
        let (data, response) = try await session.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse,
              (200..<300).contains(httpResponse.statusCode) else {
            throw URLError(.badServerResponse)
        }
        return try decoder.decode(type, from: data)
    }
}
```

**project.yml update** — add `Models` and `Networking` subdirectories to the BarDown sources. The existing `path: BarDown` source entry is recursive and will automatically pick up new subdirectories — no change needed IF the existing project.yml uses recursive source scanning. Verify: if `sources: - path: BarDown` is already present in project.yml (it is per 02-01-SUMMARY.md), then no change to project.yml is needed.

HOWEVER: The `APIBaseURL` and `APIKey` entries must be added to the app's Info.plist build settings in project.yml so they can be read at runtime:

```yaml
# In targets.BarDown.settings.base, add:
INFOPLIST_KEY_APIBaseURL: "$(API_BASE_URL)"
INFOPLIST_KEY_APIKey: "$(API_KEY)"
```

Also add xcconfig reference for environment injection:
```yaml
# In targets.BarDown.settings:
configs:
  Debug:
    API_BASE_URL: "http://localhost:8080"
    API_KEY: ""
```

After editing project.yml, regenerate the Xcode project:
```bash
cd BarDown-iOS && xcodegen generate
```

**Fallback:** If xcodegen is not in PATH, add it via: `brew install xcodegen`

**Security note:** The API key defaults to empty string in Debug config. The development fallback in the backend (APIKeyMiddleware) already allows empty-key requests with a logged warning. This is safe for local dev. Production keys will be injected via Xcode Cloud build settings.
  </action>
  <verify>
    <automated>xcodebuild test -project BarDown-iOS/BarDown.xcodeproj -scheme BarDown -destination 'platform=iOS Simulator,name=iPhone 17 Pro' -only-testing:BarDownTests/GameModelTests 2>&1 | tail -20</automated>
    <manual>GameModelTests should now PASS (GREEN phase). Tests in ScoreboardViewModelTests and DateStripTests still fail because ViewModel types don't exist yet — that is correct.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    `xcodebuild build` exits 0. `GameModelTests` suite passes (GREEN). `APIClient.shared.fetchGames(for:)` and `APIClient.shared.fetchAvailableDates(from:to:)` compile correctly. API key is read from Info.plist build setting.
  </done>
</task>

</tasks>

<verification>
- `xcodebuild build` exits 0 — app and test targets compile
- `GameModelTests` pass: JSON from fixture decodes into [GameModel] correctly (3 games, correct statuses, TeamModel fields present)
- `GameStatus` sorts: live &lt; scheduled &lt; final
- `APIClient` compiles with `@MainActor` annotation and reads keys from `Bundle.main`
- `DateFormatter` in `GameEndpoint` uses `America/New_York` timezone
</verification>

<success_criteria>
GameModel and TeamModel decode the fixture JSON correctly. APIClient compiles with correct endpoint construction. GameModelTests (from Plan 03-02) pass GREEN. ScoreboardViewModel and DateStrip tests still fail — expected, will be fixed in 03-04.
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoreboard/03-03-SUMMARY.md`
</output>

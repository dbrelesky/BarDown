---
phase: 03-scoreboard
plan: 06
type: execute
wave: 4
depends_on: [03-04, 03-05]
files_modified:
  - BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardView.swift
  - BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardStates.swift
  - BarDown-iOS/BarDown/Features/Scoreboard/PullToRefreshView.swift
  - BarDown-iOS/BarDown/Tabs/ScoreboardTab.swift
autonomous: true
requirements: [SCOR-01, SCOR-06, SCOR-07]

must_haves:
  truths:
    - "App launches to ScoreboardTab showing today's games fetched from the API"
    - "Games are grouped into LIVE, UPCOMING, FINAL sections with section headers"
    - "Final games section shows first 3 then 'Show X more' expand button"
    - "Pulling down shows a bouncing lacrosse ball animation (not the default iOS spinner)"
    - "Loading state shows skeleton game cards (.redacted)"
    - "Empty state shows goal icon + 'Sorry folks, no ball scheduled today.'"
    - "Error state shows message + retry button"
    - "DateStripView is pinned at top; tapping a date reloads the correct day's games"
    - "Calendar icon in toolbar opens CalendarSheetView half-sheet"
    - "All tests pass including GlassAuditTests"
  artifacts:
    - path: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardView.swift"
      provides: "Main scoreboard list with section grouping, .task(id:) fetch, calendar sheet"
      exports: ["ScoreboardView"]
      min_lines: 80
    - path: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardStates.swift"
      provides: "LoadingView (skeleton), EmptyView, ErrorView with retry"
      exports: ["ScoreboardLoadingView", "ScoreboardEmptyView", "ScoreboardErrorView"]
    - path: "BarDown-iOS/BarDown/Features/Scoreboard/PullToRefreshView.swift"
      provides: "Custom bouncing lacrosse ball animation shown during pull-to-refresh"
      exports: ["PullToRefreshView"]
    - path: "BarDown-iOS/BarDown/Tabs/ScoreboardTab.swift"
      provides: "Entry point tab — wraps ScoreboardView in NavigationStack"
  key_links:
    - from: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardView.swift"
      to: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift"
      via: "@State private var viewModel = ScoreboardViewModel() + .task(id: viewModel.selectedDate)"
      pattern: "\\.task\\(id: viewModel\\.selectedDate\\)"
    - from: "BarDown-iOS/BarDown/Tabs/ScoreboardTab.swift"
      to: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardView.swift"
      via: "ScoreboardView() as body of NavigationStack"
      pattern: "ScoreboardView"
---

<objective>
Compose all previous components into the working Scoreboard screen and replace the placeholder `ScoreboardTab.swift`. Wire up the full data flow: ViewModel → DateStrip → GameCards, with section grouping, collapse/expand, custom pull-to-refresh, and all three states (loading, empty, error).

Purpose: This plan is the integration — making all prior pieces work together as the app's default landing screen. After this plan, the app is fully functional end-to-end.

Output: ScoreboardView (main list), ScoreboardStates (loading/empty/error), PullToRefreshView (custom animation), and updated ScoreboardTab.swift.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scoreboard/03-RESEARCH.md
@.planning/phases/03-scoreboard/03-04-SUMMARY.md
@.planning/phases/03-scoreboard/03-05-SUMMARY.md

@BarDown-iOS/BarDown/Tabs/ScoreboardTab.swift
@BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift
@BarDown-iOS/BarDown/Features/Scoreboard/GameCardView.swift
@BarDown-iOS/BarDown/Features/Scoreboard/DateStripView.swift
@BarDown-iOS/BarDown/Features/Scoreboard/CalendarSheetView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScoreboardStates and PullToRefreshView</name>
  <files>
    BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardStates.swift,
    BarDown-iOS/BarDown/Features/Scoreboard/PullToRefreshView.swift
  </files>
  <action>
**ScoreboardStates.swift** — loading, empty, and error state views:

```swift
import SwiftUI

// MARK: - Loading (skeleton cards)

struct ScoreboardLoadingView: View {
    var body: some View {
        VStack(spacing: 12) {
            ForEach(0..<5, id: \.self) { _ in
                GameCardView(game: .placeholder)
                    .redacted(reason: .placeholder)
                    .shimmering()
            }
        }
        .padding(.horizontal)
        .allowsHitTesting(false)
    }
}

// Shimmering modifier — subtle animated opacity pulse for skeleton loading
extension View {
    func shimmering() -> some View {
        self.modifier(ShimmerModifier())
    }
}

private struct ShimmerModifier: ViewModifier {
    @State private var phase: CGFloat = 0

    func body(content: Content) -> some View {
        content
            .opacity(0.6 + 0.4 * sin(phase))
            .onAppear {
                withAnimation(.easeInOut(duration: 1.2).repeatForever(autoreverses: true)) {
                    phase = .pi
                }
            }
    }
}

// MARK: - Empty State

struct ScoreboardEmptyView: View {
    var body: some View {
        VStack(spacing: 20) {
            Spacer()
            // Empty goal illustration — use SF Symbol as stand-in for now
            // (Phase 4+ will add a custom illustration asset)
            Image(systemName: "sportscourt")
                .resizable()
                .scaledToFit()
                .frame(width: 80, height: 80)
                .foregroundStyle(.tertiary)

            Text("Sorry folks, no ball scheduled today.")
                .font(.headline)
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)
            Spacer()
        }
    }
}

// MARK: - Error State

struct ScoreboardErrorView: View {
    let message: String
    let retryAction: () async -> Void

    var body: some View {
        VStack(spacing: 16) {
            Spacer()
            Image(systemName: "wifi.slash")
                .font(.system(size: 48))
                .foregroundStyle(.tertiary)

            Text("Couldn't load scores")
                .font(.headline)
                .foregroundStyle(.secondary)

            Text(message)
                .font(.caption)
                .foregroundStyle(.tertiary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 40)

            Button("Try Again") {
                Task { await retryAction() }
            }
            .buttonStyle(.bordered)
            Spacer()
        }
    }
}
```

**PullToRefreshView.swift** — custom bouncing lacrosse ball animation:

```swift
import SwiftUI

// PreferenceKey to track scroll offset for custom pull-to-refresh
struct ScrollOffsetKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

// The lacrosse ball animation view shown during pull and refresh
struct PullToRefreshView: View {
    let isRefreshing: Bool

    @State private var ballOffset: CGFloat = 0
    @State private var shadowScale: CGFloat = 1.0

    var body: some View {
        VStack(spacing: 4) {
            ZStack(alignment: .bottom) {
                // Shadow ellipse — shrinks when ball is up, grows when ball is down
                Ellipse()
                    .fill(Color.black.opacity(0.15))
                    .frame(width: 24 * shadowScale, height: 6 * shadowScale)
                    .offset(y: 22)

                // White lacrosse ball
                Circle()
                    .fill(Color.white)
                    .frame(width: 24, height: 24)
                    .shadow(color: .black.opacity(0.2), radius: 2, y: 1)
                    .offset(y: ballOffset)
            }
            .frame(height: 40)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 8)
        .onChange(of: isRefreshing) { _, newValue in
            if newValue {
                startBouncing()
            } else {
                stopBouncing()
            }
        }
        .onAppear {
            if isRefreshing { startBouncing() }
        }
    }

    private func startBouncing() {
        withAnimation(
            .interpolatingSpring(stiffness: 180, damping: 8)
            .repeatForever(autoreverses: true)
        ) {
            ballOffset = -16
            shadowScale = 0.6
        }
    }

    private func stopBouncing() {
        withAnimation(.easeOut(duration: 0.2)) {
            ballOffset = 0
            shadowScale = 1.0
        }
    }
}
```

**Note on pull-to-refresh integration:** Per research (Pitfall 4), we do NOT use `.refreshable`. The `ScrollOffsetKey` is used in `ScoreboardView` (Task 2) to detect pull distance and trigger refresh. `PullToRefreshView` is displayed at the top of the scroll content when `isRefreshing == true` or when pull distance exceeds threshold.
  </action>
  <verify>
    <automated>xcodebuild build -project BarDown-iOS/BarDown.xcodeproj -scheme BarDown -destination 'platform=iOS Simulator,name=iPhone 17 Pro' 2>&1 | tail -5</automated>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    `xcodebuild build` exits 0. All three state views compile. PullToRefreshView uses bouncing ball animation with `interpolatingSpring`. `ScrollOffsetKey` PreferenceKey defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ScoreboardView and update ScoreboardTab</name>
  <files>
    BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardView.swift,
    BarDown-iOS/BarDown/Tabs/ScoreboardTab.swift
  </files>
  <action>
**ScoreboardView.swift** — main scoreboard list with all features wired together:

```swift
import SwiftUI

struct ScoreboardView: View {
    @State private var viewModel = ScoreboardViewModel()
    @State private var showCalendar = false
    @State private var showAllFinals = false
    @State private var pullOffset: CGFloat = 0

    private let pullThreshold: CGFloat = 60
    private let finalCollapseCount = 3

    var body: some View {
        ScrollView {
            // Pull-to-refresh offset anchor
            GeometryReader { geo in
                Color.clear
                    .preference(
                        key: ScrollOffsetKey.self,
                        value: geo.frame(in: .named("scoreboardScroll")).minY
                    )
            }
            .frame(height: 0)

            // Custom pull-to-refresh indicator
            if viewModel.isRefreshing || pullOffset > pullThreshold {
                PullToRefreshView(isRefreshing: viewModel.isRefreshing)
                    .transition(.opacity.combined(with: .move(edge: .top)))
            }

            // Date strip (pinned below NavigationBar, above content)
            DateStripView(viewModel: viewModel)
                .padding(.vertical, 4)

            // Content area
            VStack(spacing: 12) {
                switch viewModel.state {
                case .loading:
                    ScoreboardLoadingView()

                case .empty:
                    ScoreboardEmptyView()

                case .error(let message):
                    ScoreboardErrorView(message: message) {
                        await viewModel.refresh()
                    }

                case .loaded(let games):
                    let liveGames = games.filter(\.isLive)
                    let upcomingGames = games.filter(\.isScheduled)
                    let finalGames = games.filter(\.isFinal)

                    // LIVE section
                    if !liveGames.isEmpty {
                        SectionHeader(title: "LIVE")
                        ForEach(liveGames) { game in
                            GameCardView(game: game)
                        }
                        .padding(.horizontal)
                    }

                    // UPCOMING section
                    if !upcomingGames.isEmpty {
                        SectionHeader(title: "UPCOMING")
                        ForEach(upcomingGames) { game in
                            GameCardView(game: game)
                        }
                        .padding(.horizontal)
                    }

                    // FINAL section (with collapse)
                    if !finalGames.isEmpty {
                        SectionHeader(title: "FINAL")
                        let displayedFinals = showAllFinals
                            ? finalGames
                            : Array(finalGames.prefix(finalCollapseCount))

                        ForEach(displayedFinals) { game in
                            GameCardView(game: game)
                        }
                        .padding(.horizontal)

                        if finalGames.count > finalCollapseCount && !showAllFinals {
                            Button("Show \(finalGames.count - finalCollapseCount) more final games") {
                                withAnimation(.easeInOut(duration: 0.3)) {
                                    showAllFinals = true
                                }
                            }
                            .font(.subheadline)
                            .padding(.vertical, 8)
                        }
                    }
                }
            }
            .padding(.bottom, 20)
        }
        .coordinateSpace(name: "scoreboardScroll")
        .onPreferenceChange(ScrollOffsetKey.self) { offset in
            pullOffset = offset
            // Trigger refresh when pulled past threshold and not already refreshing
            if offset > pullThreshold && !viewModel.isRefreshing {
                Task { await viewModel.refresh() }
            }
        }
        .task {
            // Load available dates for the strip on first appear
            await viewModel.loadAvailableDates()
        }
        .task(id: viewModel.selectedDate) {
            // Re-fetch games whenever selectedDate changes
            await viewModel.loadGames(for: viewModel.selectedDate)
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button {
                    showCalendar = true
                } label: {
                    Image(systemName: "calendar")
                }
            }
        }
        .sheet(isPresented: $showCalendar) {
            CalendarSheetView(
                selectedDate: Binding(
                    get: { viewModel.selectedDate },
                    set: { viewModel.selectedDate = $0 }
                ),
                gameDates: viewModel.gameDates,
                onDateSelected: { date in
                    viewModel.selectedDate = date
                    showCalendar = false
                }
            )
        }
        // Reset collapse when date changes (new day = fresh view)
        .onChange(of: viewModel.selectedDate) { _, _ in
            showAllFinals = false
        }
    }
}

// MARK: - Section Header

private struct SectionHeader: View {
    let title: String

    var body: some View {
        HStack {
            Text(title)
                .font(.caption)
                .fontWeight(.bold)
                .foregroundStyle(.secondary)
                .tracking(1.5)
            Spacer()
        }
        .padding(.horizontal, 16)
        .padding(.top, 8)
    }
}
```

**ScoreboardTab.swift** — replace placeholder entirely:

```swift
import SwiftUI

struct ScoreboardTab: View {
    var body: some View {
        NavigationStack {
            ScoreboardView()
                .navigationTitle("Scores")
                .navigationBarTitleDisplayMode(.large)
        }
    }
}

#Preview {
    ScoreboardTab()
}
```

**Key wiring notes:**
- `ScrollOffsetKey` PreferenceKey (defined in PullToRefreshView.swift) detects pull distance
- `.task { await viewModel.loadAvailableDates() }` fires once on appear (no id, fires on appear only)
- `.task(id: viewModel.selectedDate) { ... }` fires on every date change AND on initial appear (Swift docs: id-based task fires once for initial value, then again on changes)
- `showAllFinals` resets on date change — fresh view for each day
- `SectionHeader` uses `.tracking(1.5)` letter-spacing for sport-app aesthetic (Claude's Discretion)
- Calendar button in toolbar (trailing) opens CalendarSheetView half-sheet
- DO NOT add `.refreshable` modifier — custom pull detection is in place
  </action>
  <verify>
    <automated>xcodebuild test -project BarDown-iOS/BarDown.xcodeproj -scheme BarDown -destination 'platform=iOS Simulator,name=iPhone 17 Pro' 2>&1 | tail -30</automated>
    <manual>Full test suite should pass: GameModelTests, ScoreboardViewModelTests, DateStripTests, GlassAuditTests all green</manual>
    <sampling_rate>run after this task commits (full suite before plan complete)</sampling_rate>
  </verify>
  <done>
    `xcodebuild test` full suite passes. `ScoreboardTab.swift` no longer shows placeholder rectangles — it renders `ScoreboardView`. All state transitions wired. Section grouping (LIVE/UPCOMING/FINAL) implemented. Final games collapse after 3. Custom pull-to-refresh connected. Calendar sheet opens from toolbar. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- Full `xcodebuild test` suite green: GameModelTests, ScoreboardViewModelTests, DateStripTests, GlassAuditTests
- ScoreboardTab.swift renders ScoreboardView (not placeholder rectangles)
- `.task(id: viewModel.selectedDate)` in ScoreboardView — auto re-fetches on date change
- `.task` (no id) in ScoreboardView — loads available dates on first appear
- NO `.refreshable` modifier anywhere in ScoreboardView or ScoreboardTab
- `ScrollOffsetKey` PreferenceKey pulls offset and triggers `viewModel.refresh()` at 60pt threshold
- `finalCollapseCount = 3` and "Show X more" button appears when final games > 3
- Section headers: "LIVE", "UPCOMING", "FINAL" with letter-spaced caption font
</verification>

<success_criteria>
ScoreboardTab.swift is fully functional — fetches real games from the API, renders all game states correctly, supports date navigation and pull-to-refresh with custom lacrosse ball animation. Full test suite passes green.
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoreboard/03-06-SUMMARY.md`
</output>

---
phase: 03-scoreboard
plan: 04
type: execute
wave: 3
depends_on: [03-03]
files_modified:
  - BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift
  - BarDown-iOS/BarDown/Features/Scoreboard/DateStripView.swift
  - BarDown-iOS/BarDown/Features/Scoreboard/CalendarSheetView.swift
autonomous: true
requirements: [SCOR-04, SCOR-05, SCOR-06, SCOR-07]

must_haves:
  truths:
    - "ScoreboardViewModel manages loading/loaded/empty/error states with @Observable + @MainActor"
    - "ScoreboardViewModel holds selectedDate (defaults to today Eastern) and gameDates ([Date]) for the strip"
    - "ScoreboardViewModel.loadGames(for:) fetches via APIClient and transitions state correctly"
    - "ScoreboardViewModel.refresh() sets isRefreshing=true, calls loadGames, sets isRefreshing=false"
    - "DateStripView renders only dates in viewModel.gameDates (not all calendar days)"
    - "Tapping a date in DateStripView updates viewModel.selectedDate and scrolls to center"
    - "CalendarSheetView shows a monthly calendar with dots on game dates"
    - "Tapping a calendar date sets viewModel.selectedDate and dismisses the sheet"
    - "ScoreboardViewModelTests and DateStripTests pass (GREEN)"
  artifacts:
    - path: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift"
      provides: "@Observable @MainActor ViewModel with State enum, selectedDate, gameDates, isRefreshing"
      exports: ["ScoreboardViewModel"]
      min_lines: 60
    - path: "BarDown-iOS/BarDown/Features/Scoreboard/DateStripView.swift"
      provides: "Horizontal scrollable date selector, ScrollViewReader, LazyHStack"
      exports: ["DateStripView"]
    - path: "BarDown-iOS/BarDown/Features/Scoreboard/CalendarSheetView.swift"
      provides: "Half-sheet monthly calendar with game date dot indicators"
      exports: ["CalendarSheetView"]
  key_links:
    - from: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift"
      to: "BarDown-iOS/BarDown/Networking/APIClient.swift"
      via: "APIClient.shared.fetchGames(for:) and fetchAvailableDates(from:to:)"
      pattern: "APIClient\\.shared\\.fetch"
    - from: "BarDown-iOS/BarDown/Features/Scoreboard/DateStripView.swift"
      to: "BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift"
      via: "@Bindable viewModel — selectedDate binding"
      pattern: "@Bindable.*viewModel"
---

<objective>
Build the data and date navigation layer: the `@Observable` ScoreboardViewModel state machine, the horizontal date strip, and the monthly calendar bottom sheet.

Purpose: This is the reactive core of the scoreboard. Everything the user sees — which date is selected, which games load, what loading/empty/error state is shown — flows through the ViewModel. Date navigation completes SCOR-04 and SCOR-05.

Output: Three files in `BarDown-iOS/BarDown/Features/Scoreboard/`. ScoreboardViewModelTests and DateStripTests pass GREEN.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scoreboard/03-RESEARCH.md
@.planning/phases/03-scoreboard/03-03-SUMMARY.md

@BarDown-iOS/BarDown/Networking/APIClient.swift
@BarDown-iOS/BarDown/Models/GameModel.swift
@BarDown-iOS/BarDownTests/ScoreboardViewModelTests.swift
@BarDown-iOS/BarDownTests/DateStripTests.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScoreboardViewModel with state machine and date management</name>
  <files>BarDown-iOS/BarDown/Features/Scoreboard/ScoreboardViewModel.swift</files>
  <action>
Create directory `BarDown-iOS/BarDown/Features/Scoreboard/` and create `ScoreboardViewModel.swift`.

```swift
import Foundation
import Observation

@Observable
@MainActor
final class ScoreboardViewModel {

    enum State {
        case loading
        case loaded([GameModel])
        case empty
        case error(String)
    }

    // MARK: - Observed State

    var state: State = .loading
    var selectedDate: Date = Self.easternStartOfToday()
    var gameDates: [Date] = []   // only dates with games, for the date strip
    var isRefreshing: Bool = false

    // MARK: - Private

    private let apiClient: APIClient

    init(apiClient: APIClient = .shared) {
        self.apiClient = apiClient
    }

    // MARK: - Public Methods

    func loadGames(for date: Date) async {
        state = .loading
        do {
            let games = try await apiClient.fetchGames(for: date)
            state = games.isEmpty ? .empty : .loaded(games.sortedByStatus())
        } catch {
            state = .error(error.localizedDescription)
        }
    }

    func refresh() async {
        isRefreshing = true
        await loadGames(for: selectedDate)
        isRefreshing = false
    }

    func loadAvailableDates() async {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = TimeZone(identifier: "America/New_York")!
        let today = Self.easternStartOfToday()
        let from = cal.date(byAdding: .day, value: -30, to: today)!
        let to   = cal.date(byAdding: .day, value:  30, to: today)!

        do {
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd"
            formatter.timeZone = TimeZone(identifier: "America/New_York")!

            let dateStrings = try await apiClient.fetchAvailableDates(from: from, to: to)
            gameDates = dateStrings.compactMap { formatter.date(from: $0) }
        } catch {
            // Non-fatal: date strip will show empty, user can still navigate
            gameDates = []
        }
    }

    // MARK: - Private Helpers

    static func easternStartOfToday() -> Date {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = TimeZone(identifier: "America/New_York")!
        return cal.startOfDay(for: .now)
    }
}

// MARK: - GameModel sort extension

extension [GameModel] {
    func sortedByStatus() -> [GameModel] {
        sorted {
            if $0.gameStatus != $1.gameStatus {
                return $0.gameStatus < $1.gameStatus
            }
            return $0.startTime < $1.startTime
        }
    }
}
```

**Swift 6.2 concurrency note:** `@Observable @MainActor` is the correct pattern for iOS 26 per the research doc. The `APIClient` is also `@MainActor` so all calls stay on the main actor without sendability friction.

**No `@StateObject` / `ObservableObject`** — use `@Observable` macro only (research locked decision).
  </action>
  <verify>
    <automated>xcodebuild build -project BarDown-iOS/BarDown.xcodeproj -scheme BarDown -destination 'platform=iOS Simulator,name=iPhone 17 Pro' 2>&1 | tail -5</automated>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    `xcodebuild build` exits 0. `ScoreboardViewModel` compiles with `@Observable`, `@MainActor`, correct `State` enum, `selectedDate`, `gameDates`, `isRefreshing`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DateStripView and CalendarSheetView</name>
  <files>
    BarDown-iOS/BarDown/Features/Scoreboard/DateStripView.swift,
    BarDown-iOS/BarDown/Features/Scoreboard/CalendarSheetView.swift
  </files>
  <action>
**DateStripView.swift** — horizontal scrollable date selector:

```swift
import SwiftUI

struct DateStripView: View {
    @Bindable var viewModel: ScoreboardViewModel

    private let formatter: DateFormatter = {
        let f = DateFormatter()
        f.dateFormat = "EEE\nMMMd"  // "Wed\nMar5"
        f.timeZone = TimeZone(identifier: "America/New_York")!
        return f
    }()

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView(.horizontal, showsIndicators: false) {
                LazyHStack(spacing: 4) {
                    ForEach(viewModel.gameDates, id: \.self) { date in
                        DateCell(
                            date: date,
                            isSelected: Calendar.current.isDate(date, inSameDayAs: viewModel.selectedDate),
                            formatter: formatter
                        )
                        .id(date)
                        .onTapGesture {
                            withAnimation(.spring(duration: 0.25)) {
                                viewModel.selectedDate = date
                                proxy.scrollTo(date, anchor: .center)
                            }
                        }
                    }
                }
                .padding(.horizontal, 16)
            }
            .onAppear {
                // Scroll to today on appear
                if let today = viewModel.gameDates.first(where: {
                    Calendar.current.isDate($0, inSameDayAs: .now)
                }) {
                    proxy.scrollTo(today, anchor: .center)
                } else if let selected = viewModel.gameDates.first(where: {
                    Calendar.current.isDate($0, inSameDayAs: viewModel.selectedDate)
                }) {
                    proxy.scrollTo(selected, anchor: .center)
                }
            }
        }
        .frame(height: 60)
    }
}

private struct DateCell: View {
    let date: Date
    let isSelected: Bool
    let formatter: DateFormatter

    var body: some View {
        Text(formatter.string(from: date))
            .font(.caption2)
            .fontWeight(isSelected ? .semibold : .regular)
            .multilineTextAlignment(.center)
            .foregroundStyle(isSelected ? .primary : .secondary)
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background {
                if isSelected {
                    Capsule()
                        .fill(.tint.opacity(0.15))
                        .overlay(Capsule().stroke(.tint, lineWidth: 1))
                }
            }
            .animation(.easeInOut(duration: 0.15), value: isSelected)
    }
}
```

**Design notes (per CONTEXT.md):**
- Understated, not pill-shaped as default — only selected date gets subtle tint highlight
- No padding pills on unselected dates
- Focus stays on game cards below

**CalendarSheetView.swift** — half-sheet monthly calendar:

```swift
import SwiftUI

struct CalendarSheetView: View {
    @Binding var selectedDate: Date
    let gameDates: [Date]
    let onDateSelected: (Date) -> Void

    @State private var displayedMonth: Date = .now

    private var calendarDates: [Date] {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = TimeZone(identifier: "America/New_York")!
        // All days in displayed month
        let range = cal.range(of: .day, in: .month, for: displayedMonth)!
        let firstDay = cal.date(from: cal.dateComponents([.year, .month], from: displayedMonth))!
        return range.compactMap { day in
            cal.date(byAdding: .day, value: day - 1, to: firstDay)
        }
    }

    private let columns = Array(repeating: GridItem(.flexible()), count: 7)

    var body: some View {
        NavigationStack {
            VStack(spacing: 16) {
                // Month navigation
                HStack {
                    Button {
                        advanceMonth(by: -1)
                    } label: {
                        Image(systemName: "chevron.left")
                    }
                    Spacer()
                    Text(displayedMonth, format: .dateTime.month(.wide).year())
                        .font(.headline)
                    Spacer()
                    Button {
                        advanceMonth(by: 1)
                    } label: {
                        Image(systemName: "chevron.right")
                    }
                }
                .padding(.horizontal)

                // Day-of-week headers
                HStack {
                    ForEach(["S","M","T","W","T","F","S"], id: \.self) { day in
                        Text(day)
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                            .frame(maxWidth: .infinity)
                    }
                }
                .padding(.horizontal)

                // Calendar grid
                LazyVGrid(columns: columns, spacing: 8) {
                    // Leading offset for first weekday
                    ForEach(0..<leadingOffset, id: \.self) { _ in
                        Color.clear.frame(height: 36)
                    }
                    ForEach(calendarDates, id: \.self) { date in
                        let hasGames = gameDates.contains { Calendar.current.isDate($0, inSameDayAs: date) }
                        let isSelected = Calendar.current.isDate(date, inSameDayAs: selectedDate)
                        DayCell(date: date, hasGames: hasGames, isSelected: isSelected)
                            .onTapGesture {
                                guard hasGames else { return }
                                onDateSelected(date)
                            }
                    }
                }
                .padding(.horizontal)

                Spacer()
            }
            .padding(.top, 16)
            .navigationTitle("Select Date")
            .navigationBarTitleDisplayMode(.inline)
        }
        .presentationDetents([.medium])
        .presentationDragIndicator(.visible)
    }

    private var leadingOffset: Int {
        var cal = Calendar(identifier: .gregorian)
        cal.firstWeekday = 1  // Sunday
        let firstDay = cal.date(from: cal.dateComponents([.year, .month], from: displayedMonth))!
        return cal.component(.weekday, from: firstDay) - 1
    }

    private func advanceMonth(by value: Int) {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = TimeZone(identifier: "America/New_York")!
        displayedMonth = cal.date(byAdding: .month, value: value, to: displayedMonth) ?? displayedMonth
    }
}

private struct DayCell: View {
    let date: Date
    let hasGames: Bool
    let isSelected: Bool

    var body: some View {
        VStack(spacing: 2) {
            Text(date, format: .dateTime.day())
                .font(.callout)
                .fontWeight(isSelected ? .bold : .regular)
                .foregroundStyle(hasGames ? .primary : .tertiary)
                .frame(width: 32, height: 32)
                .background {
                    if isSelected {
                        Circle().fill(.tint)
                    }
                }

            // Dot indicator for dates with games
            Circle()
                .fill(hasGames ? Color.accentColor : .clear)
                .frame(width: 4, height: 4)
        }
        .opacity(hasGames ? 1.0 : 0.4)
    }
}
```
  </action>
  <verify>
    <automated>xcodebuild test -project BarDown-iOS/BarDown.xcodeproj -scheme BarDown -destination 'platform=iOS Simulator,name=iPhone 17 Pro' -only-testing:BarDownTests/ScoreboardViewModelTests -only-testing:BarDownTests/DateStripTests 2>&1 | tail -20</automated>
    <manual>ScoreboardViewModelTests and DateStripTests should now PASS (GREEN phase)</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    `xcodebuild build` exits 0. `DateStripView` and `CalendarSheetView` compile with correct `@Bindable` bindings and `presentationDetents([.medium])`. `ScoreboardViewModelTests` and `DateStripTests` pass GREEN.
  </done>
</task>

</tasks>

<verification>
- `xcodebuild build` exits 0 — all targets compile
- `ScoreboardViewModelTests` pass: state transitions loading→loaded, loading→empty, loading→error all correct; refresh sets isRefreshing
- `DateStripTests` pass: only game dates shown, date selection updates viewModel.selectedDate
- `CalendarSheetView` uses `.presentationDetents([.medium])` and `.presentationDragIndicator(.visible)`
- No `.glassEffect()` calls in any new files (GlassAuditTests still pass)
- `DateFormatter` in GameEndpoint and ViewModel uses `America/New_York` timezone
</verification>

<success_criteria>
ScoreboardViewModel state machine complete. Date strip shows only game dates. Calendar sheet is a half-sheet with dot indicators. ScoreboardViewModelTests and DateStripTests pass GREEN. GlassAuditTests still pass (no glass leaks introduced).
</success_criteria>

<output>
After completion, create `.planning/phases/03-scoreboard/03-04-SUMMARY.md`
</output>

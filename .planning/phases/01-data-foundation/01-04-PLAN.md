---
phase: 01-data-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - Sources/App/Scraper/ScraperScheduler.swift
  - Sources/App/Scraper/DataReconciler.swift
autonomous: true
gap_closure: true
requirements: [DATA-01, DATA-04]

must_haves:
  truths:
    - "ScraperScheduler calls scrapeBoxScore() for games that are live or recently completed"
    - "Box score data (quarter scores, player stats) flows from scraper through DataReconciler into the database"
    - "Box score scraping does not block or delay scoreboard scraping"
  artifacts:
    - path: "Sources/App/Scraper/ScraperScheduler.swift"
      provides: "Box score scraping loop after scoreboard scraping"
      contains: "scrapeBoxScore"
    - path: "Sources/App/Scraper/DataReconciler.swift"
      provides: "reconcileBoxScore called from scheduler pipeline"
      contains: "reconcileBoxScore"
  key_links:
    - from: "Sources/App/Scraper/ScraperScheduler.swift"
      to: "Sources/App/Scraper/StatBroadcastScraper.swift"
      via: "scrapeBoxScore() call for each game with externalID"
      pattern: "scrapeBoxScore"
    - from: "Sources/App/Scraper/ScraperScheduler.swift"
      to: "Sources/App/Scraper/DataReconciler.swift"
      via: "reconcileBoxScore() call with parsed box score data"
      pattern: "reconcileBoxScore"
---

<objective>
Wire the inactive box score scraping path into the ScraperScheduler so that player-level stats and quarter-by-quarter scores are fetched for live and completed games.

Purpose: BoxScoreParser, StatBroadcastScraper.scrapeBoxScore(), and DataReconciler.reconcileBoxScore() are all fully implemented but the scheduler never calls them. This gap means no player stats or quarter scores flow into the database during normal operation.

Output: ScraperScheduler calls box score scraping for games that have a StatBroadcast external ID, after each conference scoreboard scrape.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-02-SUMMARY.md
@.planning/phases/01-data-foundation/01-VERIFICATION.md

@Sources/App/Scraper/ScraperScheduler.swift
@Sources/App/Scraper/StatBroadcastScraper.swift
@Sources/App/Scraper/DataReconciler.swift
@Sources/App/Scraper/HTMLParsers/BoxScoreParser.swift
@Sources/App/Models/Game.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire box score scraping into ScraperScheduler</name>
  <files>Sources/App/Scraper/ScraperScheduler.swift</files>
  <action>
    Add a `scrapeBoxScores(for:)` method to `ScraperScheduler` that:

    1. After `scrapeConference()` completes for each conference in the tick loop, query the database for games in that conference that are "live" or "final" status AND have a non-nil `externalID` (StatBroadcast game ID).

    2. For each such game, call `statBroadcastScraper.scrapeBoxScore(gameID: game.externalID!, confID: confIDForConference)` where `confIDForConference` comes from `StatBroadcastScraper.conferenceIDs[conf.abbreviation]?.first ?? conf.abbreviation.lowercased()`.

    3. If `scrapeBoxScore` returns a non-nil `ScrapedBoxScore`, call `reconciler.reconcileBoxScore(boxScore, gameID: game.id!, on: app.db)`.

    4. Wrap each individual game's box score scrape in a do/catch so one failure doesn't stop the others. Log warnings on failure but continue.

    5. Only attempt box score scraping for games that don't already have player stats (check `game.$playerStats.value?.isEmpty != false` or do a count query). This avoids re-scraping completed games that already have full stats.

    6. Add the call to `scrapeBoxScores(for:)` inside the `scrapeConference()` method, after the NCAA/StatBroadcast scoreboard scraping is done. Pass the conference abbreviation.

    Important: The StatBroadcast XHR endpoints are unverified (selectors are speculative). This code path will likely return empty results until a live game browser audit is done. That is expected and acceptable -- the wiring must exist so that when selectors are updated, data flows automatically.
  </action>
  <verify>
    <automated>cd /Users/darrenbrelesky/Documents/claude-code/BarDown && swift build 2>&1 | tail -5</automated>
    <manual>Verify ScraperScheduler.swift contains scrapeBoxScore calls and the method queries for live/final games</manual>
  </verify>
  <done>ScraperScheduler has an active code path that calls scrapeBoxScore() for live/final games with external IDs, and pipes results through reconcileBoxScore(). swift build passes with 0 errors.</done>
</task>

</tasks>

<verification>
- `swift build` passes with zero errors
- `grep -n "scrapeBoxScore" Sources/App/Scraper/ScraperScheduler.swift` returns multiple matches (method definition + call site)
- The box score scraping is gated behind game status (live/final) and presence of externalID
</verification>

<success_criteria>
ScraperScheduler has a live code path: scrapeConference() -> query live/final games -> scrapeBoxScore() -> reconcileBoxScore(). The path compiles and will activate automatically once StatBroadcast selectors are verified during a live game audit.
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-04-SUMMARY.md`
</output>

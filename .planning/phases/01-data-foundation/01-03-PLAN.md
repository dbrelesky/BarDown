---
phase: 01-data-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - Sources/App/Controllers/GameController.swift
  - Sources/App/Controllers/TeamController.swift
  - Sources/App/DTOs/GameResponse.swift
  - Sources/App/DTOs/BoxScoreResponse.swift
  - Sources/App/DTOs/ScheduleResponse.swift
  - Sources/App/DTOs/TeamBrief.swift
  - Sources/App/routes.swift
  - railway.toml
autonomous: false
requirements:
  - DATA-02
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "GET /api/v1/games/today returns JSON array of today's games with team names, scores, status, and rankings"
    - "GET /api/v1/games/:gameID/boxscore returns quarter scores, team stats, and player stat lines for a completed game"
    - "GET /api/v1/teams/:teamID/schedule returns a team's season schedule with game results"
    - "API responses use DTOs (not raw Fluent models) with clean JSON structure"
    - "Backend is deployed to Railway and accessible via public URL"
  artifacts:
    - path: "Sources/App/Controllers/GameController.swift"
      provides: "Route handlers for /api/v1/games endpoints"
      exports: ["GameController"]
      contains: "todaysGames"
    - path: "Sources/App/Controllers/TeamController.swift"
      provides: "Route handlers for /api/v1/teams endpoints"
      exports: ["TeamController"]
      contains: "teamSchedule"
    - path: "Sources/App/DTOs/GameResponse.swift"
      provides: "Clean JSON response shape for game data"
      contains: "struct GameResponse"
    - path: "Sources/App/DTOs/BoxScoreResponse.swift"
      provides: "Clean JSON response shape for box score data"
      contains: "struct BoxScoreResponse"
    - path: "railway.toml"
      provides: "Railway deployment configuration"
      contains: "builder"
  key_links:
    - from: "Sources/App/Controllers/GameController.swift"
      to: "Sources/App/Models/Game.swift"
      via: "Fluent queries with eager loading (.with) for teams, quarter scores, player stats"
      pattern: "Game\\.query.*\\.with"
    - from: "Sources/App/Controllers/GameController.swift"
      to: "Sources/App/DTOs/GameResponse.swift"
      via: "Model-to-DTO mapping in route handlers"
      pattern: "GameResponse\\(from:"
    - from: "Sources/App/routes.swift"
      to: "Sources/App/Controllers/GameController.swift"
      via: "Route registration: try app.register(collection: GameController())"
      pattern: "register\\(collection:"
---

<objective>
Build the REST API endpoints that serve game data as clean JSON, and deploy the complete backend to Railway.

Purpose: This plan makes the data accessible. The iOS app (future phases) will consume these endpoints. The API must serve today's games, full box scores, and team schedules — the three core data views for BarDown. Deployment to Railway makes it a live, accessible service.

Output: Three REST endpoints returning clean DTO-shaped JSON, deployed and running on Railway with managed PostgreSQL.
</objective>

<execution_context>
@/Users/darrenbrelesky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darrenbrelesky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-foundation/01-RESEARCH.md
@.planning/phases/01-data-foundation/01-01-SUMMARY.md
@.planning/phases/01-data-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build REST API controllers and DTOs</name>
  <files>
    Sources/App/Controllers/GameController.swift
    Sources/App/Controllers/TeamController.swift
    Sources/App/DTOs/GameResponse.swift
    Sources/App/DTOs/BoxScoreResponse.swift
    Sources/App/DTOs/ScheduleResponse.swift
    Sources/App/DTOs/TeamBrief.swift
    Sources/App/routes.swift
  </files>
  <action>
**DTOs (all conform to Vapor's `Content` protocol for automatic JSON serialization):**

**TeamBrief.swift:**
- id (UUID), name (String), abbreviation (String), conference (String), logoAssetName (String?), record (String? — formatted as "W-L"), ranking (Int?)

**GameResponse.swift:**
- id (UUID), homeTeam (TeamBrief), awayTeam (TeamBrief), homeScore (Int), awayScore (Int), status (String), period (String?), clock (String?), startTime (Date), quarterScores ([QuarterScoreDTO] — quarter, homeScore, awayScore)
- Init from Fluent Game model (requires eager-loaded homeTeam, awayTeam, quarterScores)

**BoxScoreResponse.swift:**
- game (GameResponse), homeTeamStats (TeamStatsDTO), awayTeamStats (TeamStatsDTO), homePlayers ([PlayerStatsDTO]), awayPlayers ([PlayerStatsDTO])
- TeamStatsDTO: goals, assists, shots, shotsOnGoal, saves, groundBalls, faceoffsWon, faceoffsLost, turnovers, penalties
- PlayerStatsDTO: playerName (String), number (String?), position (String?), goals, assists, points, shots, saves, groundBalls, faceoffsWon, faceoffsLost, turnovers
- Init from Fluent Game model (requires eager-loaded everything)

**ScheduleResponse.swift:**
- team (TeamBrief), games ([ScheduleGameDTO])
- ScheduleGameDTO: gameID (UUID), opponent (TeamBrief), isHome (Bool), score (String? — "W 12-8" or "L 5-10" or nil for upcoming), status (String), startTime (Date)

**GameController.swift (RouteCollection):**
Registered at `/api/v1/games`

Endpoints:
1. `GET /api/v1/games/today` — Returns all games for today (midnight-to-midnight America/New_York, handles DST transitions)
   - Query Game where startTime >= today start AND startTime < tomorrow start
   - Eager load: homeTeam, awayTeam, quarterScores
   - Sort by startTime ascending
   - Map to [GameResponse]
   - Optional query param `?conference=ACC` to filter by conference

2. `GET /api/v1/games/date/:date` — Returns all games for a specific date (format: yyyy-MM-dd)
   - Same logic as today but for the specified date
   - Returns 400 if date format is invalid

3. `GET /api/v1/games/:gameID/boxscore` — Returns full box score for a game
   - Eager load: homeTeam, awayTeam, quarterScores, playerStats (with player), gameStats
   - Map to BoxScoreResponse
   - Returns 404 if game not found

**TeamController.swift (RouteCollection):**
Registered at `/api/v1/teams`

Endpoints:
1. `GET /api/v1/teams/:teamID/schedule` — Returns team's 2026 season schedule
   - Query all Games where homeTeam == teamID OR awayTeam == teamID, season == 2026
   - Eager load: homeTeam, awayTeam
   - Sort by startTime ascending
   - Map to ScheduleResponse

2. `GET /api/v1/teams` — Returns all teams grouped by conference
   - Eager load: conference
   - Return as dictionary/grouped structure

**routes.swift update:**
- Register GameController and TeamController as route collections
- Keep the /health endpoint

All route handler functions must be marked `@Sendable`.
  </action>
  <verify>
    <automated>cd /Users/darrenbrelesky/Documents/claude-code/BarDown && swift build 2>&1 | tail -5</automated>
    <manual>Start app, curl each endpoint: GET /api/v1/games/today, GET /api/v1/games/{id}/boxscore, GET /api/v1/teams/{id}/schedule. Verify JSON shape matches DTO definitions.</manual>
  </verify>
  <done>All 5 API endpoints compile and return properly shaped JSON. DTOs decouple API responses from Fluent models. GameResponse includes team info, scores, status. BoxScoreResponse includes player stats and quarter scores. ScheduleResponse shows full season for a team.</done>
</task>

<task type="auto">
  <name>Task 2: Deploy to Railway with managed PostgreSQL</name>
  <files>
    railway.toml
  </files>
  <action>
**railway.toml:**
Create Railway configuration file:
```toml
[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
```

**Deployment steps (all via CLI):**
1. Install Railway CLI if not present: `brew install railway` (or `npm i -g @railway/cli`)
2. `railway login` — authenticate
3. `railway init` — create new project named "bardown"
4. `railway add --plugin postgresql` — add managed Postgres (Railway auto-injects DATABASE_URL)
5. Update configure.swift to parse DATABASE_URL if present (Railway format: `postgresql://user:pass@host:port/db`)
6. `railway up` — deploy from Dockerfile
7. Verify timezone handling: test that "today's games" boundary correctly shifts during DST spring-forward (March) and fall-back (November) transitions
8. Verify: `curl https://{railway-url}/health` returns ok
8. Verify: `curl https://{railway-url}/api/v1/games/today` returns JSON (may be empty array if no games scraped yet)

**Environment considerations:**
- Railway automatically injects DATABASE_URL for the Postgres plugin
- configure.swift must handle both DATABASE_URL (production) and individual env vars (local dev)
- Ensure migrations run automatically on deploy (Vapor's `app.autoMigrate()` in configure.swift for production, or use `swift run App migrate --yes` as a Railway deploy command)
  </action>
  <verify>
    <automated>curl -s https://bardown.up.railway.app/health 2>/dev/null || echo "Deployment URL TBD — verify after railway up"</automated>
    <manual>Visit Railway dashboard to confirm service is running. Curl /health and /api/v1/games/today from the public URL.</manual>
  </verify>
  <done>Backend is live on Railway. /health returns 200. /api/v1/games/today returns JSON. PostgreSQL is managed and connected. Scraper is running in the background.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete backend is live and serving data</name>
  <files>None — verification only</files>
  <action>
Human verification of the complete Phase 1 backend deployment.

What was built: Complete Phase 1 backend — Vapor server on Railway with PostgreSQL, scraping StatBroadcast/NCAA for 5 D1 lacrosse conferences, serving REST JSON API.

How to verify:
1. Open the Railway deployment URL in a browser or use curl
2. Check `GET /health` returns `{"status":"ok"}`
3. Check `GET /api/v1/games/today` — should return games if any D1 lacrosse games are scheduled today
4. If games exist, pick one game ID and check `GET /api/v1/games/{gameID}/boxscore` — should return quarter scores and player stats for completed games
5. Pick any team ID and check `GET /api/v1/teams/{teamID}/schedule` — should return that team's season schedule
6. Verify data freshness: check that game scores match what's on StatBroadcast or NCAA's site
7. Check Railway dashboard: service is running, Postgres is connected, no error logs

Resume signal: Type "approved" if all endpoints return correct data, or describe any issues found.
  </action>
  <verify>Human visually confirms API responses match expected data from StatBroadcast/NCAA sources</verify>
  <done>All API endpoints return correct, fresh data. Backend is stable on Railway. Phase 1 success criteria met.</done>
</task>

</tasks>

<verification>
1. `swift build` compiles all controllers and DTOs
2. GET /api/v1/games/today returns JSON array with game objects containing homeTeam, awayTeam, scores, status
3. GET /api/v1/games/:gameID/boxscore returns complete box score with player stats
4. GET /api/v1/teams/:teamID/schedule returns season schedule
5. All JSON responses use clean DTO shapes (no Fluent property wrapper artifacts)
6. Backend deployed to Railway at a public HTTPS URL
7. Scraper + API + Postgres all running together on Railway
</verification>

<success_criteria>
- All 5 API endpoints return properly shaped JSON
- DTOs cleanly separate API responses from database models
- Backend is deployed and accessible via public Railway URL
- Managed PostgreSQL on Railway stores all data
- Scraper runs in background, API serves from database
- Complete Phase 1 success criteria met: today's games, box scores, team schedules all available via API
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-foundation/01-03-SUMMARY.md`
</output>
